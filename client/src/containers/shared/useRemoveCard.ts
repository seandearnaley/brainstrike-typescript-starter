import {
  ApolloError,
  FetchResult,
  Reference,
  StoreObject,
  ApolloCache,
} from '@apollo/client';

import {
  useRemoveCardMutation,
  RemoveCardMutation,
  Card,
  PageInfo,
  CardEdge,
} from '../../generated/graphql';

// have to add _ref to the Card Edge type
type CardEdgeWithReference = CardEdge & { node: { __ref: string } };

/**
 * Safely removes a card from the category cache
 * This function avoids using the buildPageInfo function which relies on cursor decoding
 */
const removeCardFromCache = (
  cache: ApolloCache<RemoveCardMutation>,
  categoryId: string,
  cardId: string,
) => {
  try {
    cache.modify({
      id: `Category:${categoryId}`,
      fields: {
        cards(existingCards: any, { readField }) {
          // If there are no existing cards, return undefined
          if (!existingCards) return undefined;

          // Read the edges and pageInfo fields
          const edgesField = readField<CardEdgeWithReference[]>(
            'edges',
            existingCards,
          );
          const pageInfoField = readField<PageInfo>('pageInfo', existingCards);

          // If either field is missing, return undefined
          if (!edgesField || !pageInfoField) return undefined;

          // Filter out the card to be removed
          const edges = edgesField.filter(
            (edge) => edge.node.__ref !== `Card:${cardId}`,
          );

          // Update the total count
          let totalCount = pageInfoField.totalCount;
          if (totalCount > 0) totalCount--;

          // Create a new pageInfo object without using cursor decoding
          const pageInfo = {
            ...pageInfoField,
            totalCount,
            // If we removed all edges, there's no next or previous page
            hasNextPage: edges.length > 0 ? pageInfoField.hasNextPage : false,
            hasPreviousPage:
              edges.length > 0 ? pageInfoField.hasPreviousPage : false,
            // Keep the existing cursors if available
            startCursor: edges.length > 0 ? edges[0].cursor : null,
            endCursor: edges.length > 0 ? edges[edges.length - 1].cursor : null,
          };

          // Return the updated cards object
          return {
            edges,
            pageInfo,
            __typename: existingCards.__typename,
          };
        },
      },
    });
  } catch (error) {
    console.error('Error removing card from cache:', error);
  }
};

// NOTE: the rationale for using a custom hook is for the cache update,
// now the removeCard function can be used elsewhere with shared cache logic
export const useRemoveCard = (): [
  (
    id: string,
  ) => Promise<
    FetchResult<RemoveCardMutation, Record<string, any>, Record<string, any>>
  >,
  boolean,
  ApolloError | undefined,
] => {
  // note useRemoveCardMutation is generated by GraphQL Code Generator, it is a wrapped useQuery hook
  const [removeCardMutation, { loading, error }] = useRemoveCardMutation();

  const removeCard = (id: string) =>
    removeCardMutation({
      variables: {
        id,
      },
      update: (cache, { data }) => {
        if (!data || !data.removeCard || !data.removeCard.card) {
          console.warn('No data returned from removeCard mutation');
          return;
        }

        try {
          // For each category the card belongs to, update the cache
          data.removeCard.card.categories.forEach((category) => {
            if (category && category.id) {
              removeCardFromCache(cache, category.id, id);
            }
          });

          // Evict the card from the cache
          cache.evict({ id: `Card:${id}` });

          // Run garbage collection to clean up any dangling references
          cache.gc();

          console.log('Card successfully removed from cache');
        } catch (error) {
          console.error('Error updating cache after card removal:', error);
        }
      },
    });

  return [removeCard, loading, error];
};
